
# Project Brief: KGM Cables Notification System

## 1. Project Overview & Goals

### Project Description
This project is to create a simple, local web application for the owner of the KGM Cables television network. The purpose of the application is to provide a user-friendly interface for the owner to quickly send bulk notifications to customers during a service outage. The application will read customer contact information from a local CSV file.

### Core Goals & Features
- **Build a Web UI:** Create a simple, clean, and intuitive web interface that can be run locally in a browser.
- **Area-Based Targeting:** Allow the user to select a specific geographical area from a dropdown menu. The list of areas will be dynamically populated from the customer data file.
- **Multi-Channel Messaging:** Enable the user to choose between sending the notification via **SMS** or **WhatsApp**.
- **Customizable Messages:** Provide a text box with a default message template that the user can edit before sending.
- **One-Click Sending:** A single "Send" button will trigger the process of sending the message to all customers in the selected area via the chosen channel.
- **Status Feedback:** The UI must provide clear feedback to the user (e.g., "Sending...", "Messages sent successfully," or "Error").

---

## 2. Technology Stack

- **Backend:** Python 3.9+ with the Flask framework.
- **Frontend:** Standard HTML5, CSS3, and "vanilla" JavaScript (ES6+).
- **Data Processing:** Pandas library.
- **Messaging API:** Twilio API.
- **Package Management:** `pip` with a `venv` virtual environment.

---

## 3. System Design & Architecture

### Codebase Structure
The project will be organized into the following directory structure:

```
KGM_Cables/
├── app/
│   ├── __init__.py
│   └── routes.py
├── data/
│   └── customers.csv
├── static/
│   ├── css/
│   │   └── style.css
│   └── js/
│       └── script.js
├── templates/
│   └── index.html
├── .env.example
├── .gitignore
├── requirements.txt
└── run.py
```

### Data Flow
1.  **Initialization:** The user starts the server by running `python run.py`.
2.  **Page Load:** The user navigates to the web UI. The frontend JavaScript immediately calls the backend's `/api/areas` endpoint.
3.  **Area Population:** The backend reads `data/customers.csv`, finds all unique values in the 'area' column, and returns them as a JSON list. The frontend populates the "Select Area" dropdown with this list.
4.  **User Action:** The user selects an area, chooses a channel (SMS/WhatsApp), edits the message, and clicks "Send".
5.  **API Call:** The frontend JavaScript sends a `POST` request to the `/api/send` endpoint with a JSON payload containing the selected area, channel, and message content.
6.  **Backend Processing:** The backend receives the request, reads the CSV file again, and filters it to find all customers matching the specified area.
7.  **Message Dispatch:** The backend iterates through the filtered list of customers and, for each one, calls the Twilio API to send the message using the appropriate channel (SMS or WhatsApp).
8.  **Feedback:** After the loop completes, the backend returns a JSON response to the frontend indicating success (including a count of messages sent) or failure. The frontend then displays this status to the user.

### Configuration
- All secret credentials (Twilio Account SID, Auth Token, and phone numbers) must be stored in a `.env` file at the project root.
- The `.env` file should be loaded by the application at startup using the `python-dotenv` library.
- The `.gitignore` file must prevent the `.env` file from ever being committed to version control.

---

## 4. File-by-File Implementation Guide

### `run.py`
- **Purpose:** The main entry point to start the Flask application.
- **Contents Description:**
    - It should import the `create_app` function from the `app` package.
    - It should import and run `load_dotenv()` to load the `.env` file.
    - It should call `create_app()` to get the Flask app instance.
    - It should run the app in debug mode on a non-standard port like `5001` to avoid conflicts.

### `requirements.txt`
- **Purpose:** Lists all Python dependencies for `pip`.
- **Contents Description:** This file should contain the names of the required libraries, one per line: `flask`, `pandas`, `twilio`, `python-dotenv`.

### `.env.example`
- **Purpose:** A template file that shows the user which environment variables are needed.
- **Contents Description:** List the required variable names without their values: `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`, `TWILIO_PHONE_NUMBER`, `TWILIO_WHATSAPP_NUMBER`.

### `.gitignore`
- **Purpose:** Specifies files and directories for Git to ignore.
- **Contents Description:** Should include entries for the virtual environment (`venv/`, `.venv/`), the environment file (`.env`), and Python cache files (`__pycache__/`, `*.pyc`).

### `app/__init__.py`
- **Purpose:** Initializes the `app` directory as a Python package and contains the application factory.
- **Contents Description:**
    - Define a function named `create_app()`.
    - Inside this function, create an instance of the `Flask` class. When creating the instance, be sure to correctly point `static_folder` to the root `static` directory and `template_folder` to the root `templates` directory.
    - Within the application context (`with app.app_context():`), import the routes from `app.routes`. This prevents circular import errors.
    - Return the app instance.

### `app/routes.py`
- **Purpose:** Defines all backend API endpoints and contains the core business logic.
- **Contents Description:**
    - **Imports:** Import necessary modules: `jsonify`, `request`, `render_template` from Flask; `pandas`; `os`; and `Client` from `twilio.rest`.
    - **Initialization:** Load the Twilio credentials from the environment variables and initialize the Twilio `Client`. Define a constant for the path to the `customers.csv` file.
    - **`@app.route('/')`:** This route should serve the main `index.html` page from the `templates` folder.
    - **`@app.route('/api/areas', methods=['GET'])`:**
        - This endpoint's responsibility is to provide the list of unique customer areas.
        - It should read the CSV file into a pandas DataFrame, get the unique values from the 'area' column, convert them to a list, and return this list as a JSON response.
        - It must include error handling for a `FileNotFoundError`.
    - **`@app.route('/api/send', methods=['POST'])`:**
        - This endpoint handles the core message sending logic.
        - It should first get the `area`, `message`, and `channel` from the incoming JSON request body.
        - It should then read the customer CSV file and filter it to get only the customers in the specified `area`.
        - It needs to iterate over each customer in the filtered data. In each iteration, it must call the Twilio API to send the message.
        - It must use a conditional check on the `channel` variable to call the correct Twilio function for either SMS or WhatsApp, using the correct `from_` number for each.
        - It should print/log the status of each message sent for debugging purposes.
        - Finally, it should return a JSON response indicating the number of messages successfully sent.
        - It must include robust error handling for file not found or other exceptions during the process.

### `templates/index.html`
- **Purpose:** The main HTML structure of the user interface.
- **Contents Description:**
    - This file should contain the complete HTML structure for the page.
    - It needs a `<select>` element for the area dropdown.
    - It needs a set of `<input type="radio">` for the SMS/WhatsApp channel selection.
    - It needs a `<textarea>` for the message, pre-filled with a default template.
    - It needs a `<button>` to trigger the send action.
    - It needs an empty `<div>` to display status messages to the user.
    - It must link to the `style.css` and `script.js` files.

### `static/js/script.js`
- **Purpose:** All frontend interactivity and communication with the backend.
- **Contents Description:**
    - All code should be wrapped in a `DOMContentLoaded` event listener.
    - **Area Loading:** On page load, it must make a `fetch` call to `/api/areas`. It should then dynamically create `<option>` elements from the response and populate the area `<select>` dropdown.
    - **Send Button Logic:**
        - An event listener on the send button's 'click' event should trigger the main logic.
        - This logic must read the selected values from all form inputs (area, channel, message).
        - It should perform basic validation to ensure no fields are empty.
        - It must make a `POST` `fetch` call to the `/api/send` endpoint, passing the user's selections in the JSON request body.
        - It should handle the promise returned by `fetch` to update the status `<div>` with a success or error message based on the backend's response.
        - It should disable the send button while the request is in progress and re-enable it when complete.

### `static/css/style.css`
- **Purpose:** To style the web interface for a clean and professional look.
- **Contents Description:**
    - The CSS should center the main application container on the page.
    - It should provide styling for a clean, modern look (e.g., fonts, colors, spacing).
    - It must style all form elements (`select`, `textarea`, `button`).
    - The button should have distinct styles for its default, `:hover`, and `:disabled` states.
    - The status message `<div>` should have different styles (e.g., background color, text color) for different states: sending, success, and error.
